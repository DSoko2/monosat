from PIL import Image
import math
from networkx.algorithms.flow.maxflow import minimum_cut
from monosat import *
import scipy.io
from sklearn import preprocessing
import sys

import networkx as nx
import numpy as np




settings = "-nn-limit=10000 -verb=1 -nn-learn-in=0 -nn-init=2 -search=2 -decide-theories "  #
print(settings)
Monosat().init(settings)

# roughly following the UGM implementation
# https://www.cs.ubc.ca/~schmidtm/Software/UGM/graphCuts.html

data = scipy.io.loadmat(sys.argv[1])
input_data = data["t"]

#These constants were generated by UGM, independently for each noisy image.
params = [float(x)  for x in data["params"][0]]
print("Constants: " + str(params))

# transform the noisy image intensities so that they have a mean of zero and a standard deviation of 1
img = preprocessing.scale(input_data.flatten(), 0)
img = img.reshape(input_data.shape)

w, h = img.shape

g = nx.DiGraph()
s = 0
g.add_node(s)
t = 1
g.add_node(t)
n = 2
px = []
for x in range(w):
    px.append([None for y in range(h)])
for x in range(w):
    for y in range(h):
        g.add_node(n)
        px[x][y] = n
        n += 1

source_node_pots = dict()
sink_node_pots = dict()



ALPHA = params[0]
BETA = params[1]
GAMMA = params[2]
DELTA = params[3]



for x in range(w):
    for y in range(h):
        n = px[x][y]
        c = -(ALPHA + BETA * img[x, y])
        source_node_pots[(x, y)] = c
        sink_node_pots[(x, y)] = 0

edge_pots = dict()

for x in range(w):
    for y in range(h):
        if x < w - 1:
            pot_same = -(GAMMA + DELTA * 1.0 / (1.0 + abs(img[x, y] - img[x + 1, y])))
            edge_pots[((x, y), (x + 1, y))] = pot_same
            edge_pots[((x + 1, y), (x, y))] = pot_same

        if y < h - 1:
            pot_same = -(GAMMA + DELTA * 1.0 / (1.0 + abs(img[x, y] - img[x, y + 1])))
            edge_pots[((x, y), (x, y + 1))] = pot_same
            edge_pots[((x, y + 1), (x, y))] = pot_same

for x in range(w):
    for y in range(h):
        if x < w - 1:
            n1 = (x, y)
            n2 = (x + 1, y)
            p = edge_pots[n1, n2];
            sink_node_pots[n1] -= edge_pots[n1, n2]
            sink_node_pots[n2] += edge_pots[n1, n2]
        if y < h - 1:
            n1 = (x, y)
            n2 = (x, y + 1)
            sink_node_pots[n1] -= edge_pots[n1, n2]
            sink_node_pots[n2] += edge_pots[n1, n2]

for x in range(w):
    for y in range(h):
        n = px[x][y]
        c_s = source_node_pots[(x, y)]
        c_t = sink_node_pots[(x, y)]
        if c_s < c_t:
            c = c_t - c_s
            assert (c >= 0)
            g.add_edge(s, n, capacity=c)
            g.add_edge(n, t, capacity=0)
        else:
            c = c_s - c_t
            assert (c >= 0)
            g.add_edge(n, t, capacity=c)
            g.add_edge(s, n, capacity=0)

for x in range(w):
    for y in range(h):
        if x < w - 1:
            n1 = (x, y)
            n2 = (x + 1, y)
            c = -edge_pots[n1, n2]
            if (c < 0):
                c = 0
            g.add_edge(px[x][y], px[x + 1][y], capacity=c)
            g.add_edge(px[x + 1][y], px[x][y], capacity=c)
        if y < h - 1:
            n1 = (x, y)
            n2 = (x, y + 1)
            c = -edge_pots[n1, n2]
            if (c < 0):
                c = 0
            g.add_edge(px[x][y], px[x][y + 1], capacity=c)
            g.add_edge(px[x][y + 1], px[x][y], capacity=c)

flow, (ps, pt) = minimum_cut(g, s, t)

precision =  10000.0/flow #floating point constants are modelled as bitvectors in monosat; this controls how much precision they are modelled with




bvwidth = math.ceil(math.log(precision*10,2))+2 #*10 to allow for simulated 'infinite' weight edges
print("BVWidth = " + str(bvwidth))

def disc(val):
    v =  int(round(val * precision))
    assert(v>=0)
    assert(v<(1<<bvwidth))
    return v;


def undisc(val):
    return val / precision
relax = flow*0.2
drelax =disc( flow * 0.2 )#How much freedom the solver should have to deviate from the theoretical optimal denoising. How to choose this value is an open question.
dflow=disc(flow)


print("Flow: " + str(flow))
print("Relax: " + str(relax))
print("RelaxProportion: " + str(relax/flow))
print("Relax: " + str(relax) + ", precision: " + str(precision) + ", params " + str(params))

assigns = dict()
G = Graph(Graph.GraphType.int)
source = G.addNode()
assigns[source] = true()
sink = G.addNode()
assigns[sink] = false()
snodes = dict()
for x in range(w):
    for y in range(h):
        n = G.addNode()
        assigns[n] = Var("assign%d_%d" % (x, y))
        snodes[(x, y)] = n
        c_s = source_node_pots[(x, y)]
        c_t = sink_node_pots[(x, y)]
        if c_s < c_t:
            c = c_t - c_s
            assert (c >= 0)
            Assert(G.addEdge(source, n, disc(c)))
        else:
            c = c_s - c_t
            assert (c >= 0)
            Assert(G.addEdge(n, sink, disc(c)))

for x in range(w):
    for y in range(h):
        if x < w - 1:
            n1 = (x, y)
            n2 = (x + 1, y)
            c = -edge_pots[n1, n2]
            if (c <= 0):
                c = 0
            Assert(G.addUndirectedEdge(snodes[n1], snodes[n2], disc(c)))
        if y < h - 1:
            n1 = (x, y)
            n2 = (x, y + 1)
            c = -edge_pots[n1, n2]
            if (c <= 0):
                c = 0
            Assert(G.addUndirectedEdge(snodes[n1], snodes[n2], disc(c)))


for x in range(w):
    for y in range(h):
        n = snodes[(x, y)]
        e1 = G.addEdge(source, n, disc(flow *10  + relax*10 )) #multiply by 10 to simulate 'infinity' weight here
        e2 = G.addEdge(n, sink, disc(flow *10 + relax*10))  #multiply by 10 to simulate 'infinity' weight here
        AssertEq(e1, assigns[n])
        AssertEq(e2, Not(assigns[n]))

print(undisc(disc(flow - relax)))

#'relax' adds some wiggle room into the noise model, to allow monosat to explore solutions that are not quite minimal cuts
G.AssertMaxFlowLessOrEqualTo(source, sink, disc(flow + relax))
mf = G.maxFlowGreaterOrEqualTo(source, sink, disc(flow*0.95))
Assert(mf)

mnist_lenet = "lenet.prototxt"
mnist_weights = "lenet.caffemodel"

nn = NeuralNetwork(mnist_lenet, mnist_weights)

inputs = dict()
outputs = []

assert (w == 28)
assert (h == 28)
for x in range(w):
    for y in range(h):
        n = (x, y)
        bv = nn.getInput((0, 0, x, y), 10)
        inputs[n] = bv
        AssertEq(bv >= 1023, Not(assigns[snodes[n]]))
        AssertEq(bv <= 0, assigns[snodes[n]])

opt_bvwidth = 24
chosen_out=[]
opt =BitVector(opt_bvwidth,"anon")
for o in range(10):
    outputs.append(nn.getOutput((0,o),opt_bvwidth))
    chosen_out.append(outputs[-1]>=opt)

AssertExactlyOne(chosen_out)
maximize(opt)

print("Solving...")

if Solve():
    print("Solved")
    for o in outputs:
        print(o.value())
    print("opt: ")
    print(opt.value())

    flowval = G.getMaxFlow(mf)
    print("Found flow: " + str(flowval) + ", expected ~ " + str((disc(flow + relax))))
    print("Found flow: " + str(undisc(flowval) )+ " " + str((flow + relax)))
    cut = 0
    partition = set()
    partition.add(source)
    for x in range(w):
        for y in range(h):
            n = (x, y)
            sn = snodes[n]
            if (assigns[sn].value()):
                partition.add(sn)

    for u, v, data in g.edges_iter(data=True):
        c = data['capacity']
        if (u in partition) and (v not in partition):
            cut += c

    print(cut)

    img_out = np.zeros(input_data.shape)
    for x in range(w):
        for y in range(h):
            n = (x, y)
            sn = snodes[n]

            if (assigns[sn].value()):
                img_out[x, y] = 1
            else:
                img_out[x, y] = 0
    scipy.io.savemat("solution.mat", {"t": img_out})
    from matplotlib import pyplot as plt

    plt.imshow(img_out, interpolation='nearest')
    plt.show()
    assert (cut <= flow + relax)

print("Done")
